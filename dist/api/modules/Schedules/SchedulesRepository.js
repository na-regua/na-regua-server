'use strict';var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator['throw'](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{'default':mod};};Object.defineProperty(exports,'__esModule',{value:true});exports.SchedulesRepository=void 0;const index_1=require('../../../core/index');const Barbers_1=require('../Barbers');const NotificationsRepository_1=__importDefault(require('../Notifications/NotificationsRepository'));const Services_1=require('../Services');const Tickets_1=require('../Tickets');class SchedulesRepository{listByToken(req,res){return __awaiter(this,void 0,void 0,function*(){try{const barber=res.locals.barber;const from=req.query.from;const to=req.query.to;const filter={from,to};const scheduleTickets=yield Tickets_1.TicketsModel.getSchedules(barber._id,filter);return res.status(200).json({schedules:scheduleTickets});}catch(error){return(0,index_1.errorHandler)(error,res);}});}listScheduledDates(req,res){var _a;return __awaiter(this,void 0,void 0,function*(){try{const barber=res.locals.barber;const barberLimit=((_a=barber.config)===null||_a===void 0?void 0:_a.schedule_limit_days)||30;const fromDate=new Date();const limitDate=new Date(fromDate);limitDate.setDate(limitDate.getDate()+barberLimit);const filters={from:fromDate,to:limitDate};const schedules=yield Tickets_1.TicketsModel.getSchedules(barber._id,filters);const scheduledDates=schedules.map(schedule=>{var _a;return(_a=schedule.schedule)===null||_a===void 0?void 0:_a.date;});return res.status(200).json({scheduledDates});}catch(error){return(0,index_1.errorHandler)(error,res);}});}create(req,res){return __awaiter(this,void 0,void 0,function*(){try{const user=res.locals.user;const {barberId,serviceId,date,time}=req.body;const barber=yield Barbers_1.BarbersModel.findById(barberId);if(!barber){throw new index_1.HttpException(400,index_1.SYSTEM_ERRORS.BARBER_NOT_FOUND);}const service=yield Services_1.ServicesModel.findOne({barber:barberId,_id:serviceId});if(!service){throw new index_1.HttpException(400,index_1.SYSTEM_ERRORS.SERVICE_NOT_FOUND);}const isDateValid=yield Tickets_1.TicketsModel.isValidScheduleDate(barber,date,time);if(!isDateValid){throw new index_1.HttpException(400,index_1.SYSTEM_ERRORS.INVALID_SCHEDULE_DATE);}const isCustomer=barber.customers.find(customerId=>customerId.toString()===user._id.toString());const schedule=yield Tickets_1.TicketsModel.create({customer:user._id,barber:barberId,service:serviceId,approved:isCustomer,status:isCustomer?'scheduled':'pending',type:'schedule',schedule:{date,time}});if(!schedule){throw new index_1.HttpException(400,index_1.SYSTEM_ERRORS.SCHEDULE_NOT_CREATED);}const messageType=isCustomer?'CUSTOMER_SCHEDULED_APPOINTMENT':'USER_ASK_TO_SCHEDULE';yield NotificationsRepository_1.default.notifyBarberWorkers(barberId,messageType,{barber:barberId,service:serviceId,schedule:schedule._id},user.avatar._id.toString());return res.status(201).json(schedule);}catch(error){return(0,index_1.errorHandler)(error,res);}});}update(){return __awaiter(this,void 0,void 0,function*(){});}delete(){return __awaiter(this,void 0,void 0,function*(){});}}exports.SchedulesRepository=SchedulesRepository;exports.default=new SchedulesRepository();