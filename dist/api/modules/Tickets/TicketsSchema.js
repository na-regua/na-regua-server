'use strict';var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator['throw'](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};Object.defineProperty(exports,'__esModule',{value:true});exports.TicketsModel=void 0;const mongoose_1=require('mongoose');const Barbers_1=require('../Barbers');const QueueDataSchema=new mongoose_1.Schema({queueDTO:{type:mongoose_1.Schema.Types.ObjectId,ref:'Queues',required:true},position:{type:Number,required:true}},{versionKey:false,timestamps:false});const ScheduleSchema=new mongoose_1.Schema({date:{type:Date,required:true},time:{type:String,required:true}},{versionKey:false,timestamps:false});const TicketsSchema=new mongoose_1.Schema({customer:{type:mongoose_1.Schema.Types.ObjectId,ref:'Users',required:true},status:{type:String,enum:['pending','queue','scheduled','missed','served'],default:'pending'},barber:{type:mongoose_1.Schema.Types.ObjectId,ref:'Barbers',required:true},type:{type:String,enum:['queue','schedule'],required:true},service:{type:mongoose_1.Schema.Types.ObjectId,ref:'Services',required:true},queue:{type:QueueDataSchema},schedule:{type:ScheduleSchema},billed:{type:Boolean,default:false},approved:{type:Boolean,default:false},servedBy:{type:mongoose_1.Schema.Types.ObjectId,ref:'Workers'},servedAt:Date,missedAt:Date},{versionKey:false,timestamps:true,collection:'Tickets'});TicketsSchema.statics.getSchedules=function(barberId,filters){return __awaiter(this,void 0,void 0,function*(){const filter={barber:barberId,type:'schedule'};if(filters){const {from,to,customerId}=filters;if(from){const fromDate=new Date(from);const nextDay=new Date(fromDate);nextDay.setDate(nextDay.getDate()+1);filter['schedule.date']={$gte:fromDate};if(to){const toDate=new Date(to);filter['schedule.date']['$lt']=toDate;}if(!to){filter['schedule.date']['$lt']=nextDay;}}if(customerId){filter.customer=customerId;}}const offset=(filters===null||filters===void 0?void 0:filters.offset)||0;const schedules=yield this.find(filter).skip(offset);return schedules;});};TicketsSchema.statics.isValidScheduleDate=function(barber,date,time){var _a,_b;return __awaiter(this,void 0,void 0,function*(){const today=new Date();const limit=((_a=barber.config)===null||_a===void 0?void 0:_a.scheduleLimitDays)||30;const limitDate=new Date(today);limitDate.setDate(limitDate.getDate()+limit);if(date<today||date>limitDate){return false;}const day=Barbers_1.getDayToWorkDays[today.getDay()];if(!day){return false;}if(day){const isOnWorkDays=(_b=barber.config)===null||_b===void 0?void 0:_b.workDays.includes(day);if(!isOnWorkDays){return false;}}const fromDate=new Date(date);const toDate=new Date(date);toDate.setDate(toDate.getDate()+1);const hasOnThisTime=yield this.find({barber:barber._id,type:'schedule','schedule.date':{$gte:fromDate,$lt:toDate},'schedule.time':time});if(hasOnThisTime.length>0){return false;}return false;});};const TicketsModel=(0,mongoose_1.model)('Tickets',TicketsSchema);exports.TicketsModel=TicketsModel;